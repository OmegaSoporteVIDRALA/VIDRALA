name: üìù Validate Salesforce PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  validate:
    name : Salesforce Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: ‚¨áÔ∏è Checkout repository
        uses: actions/checkout@v3
        
      - name: ‚¨áÔ∏è Checkout code
        uses: actions/checkout@v4

      - name: üö´ Bloquear si hay PR abierto validado hacia la misma rama
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          CURRENT_PR_NUMBER=${{ github.event.pull_request.number }}
          echo "üîé Buscando otros PR abiertos hacia $BASE_BRANCH (excepto el actual: #$CURRENT_PR_NUMBER)"

          OPEN_PRS=$(gh pr list --state open --base "$BASE_BRANCH" --json number,headRefOid --jq '.[] | select(.number != '"$CURRENT_PR_NUMBER"')')

          if [ -z "$OPEN_PRS" ]; then
            echo "‚úÖ No hay otros PR abiertos hacia $BASE_BRANCH"
            exit 0
          fi

          for ROW in $(echo "$OPEN_PRS" | jq -c '.'); do
            SHA=$(echo "$ROW" | jq -r '.headRefOid')
            ARTIFACT_NAME="validated-deploy-id-$SHA"

            echo "üîç Buscando artifact para PR con SHA: $SHA"
            MATCHED=false

            for run_id in $(gh run list --workflow "üìù Validate Salesforce PR" --json databaseId,conclusion,event,headSha --jq '.[] | select(.conclusion == "success") | .databaseId'); do
              mkdir -p .check-temp
              gh run download "$run_id" -n "$ARTIFACT_NAME" -D .check-temp || continue

              if [ -f .check-temp/commit.txt ]; then
                ARTIFACT_SHA=$(cat .check-temp/commit.txt)
                if [ "$ARTIFACT_SHA" == "$SHA" ]; then
                  echo "‚ùå Ya existe un PR abierto hacia $BASE_BRANCH validado exitosamente (SHA: $SHA)"
                  exit 1
                fi
              fi
              rm -rf .check-temp
            done
          done

          echo "‚úÖ Ning√∫n PR abierto hacia $BASE_BRANCH ha sido validado a√∫n"
       
      - name: üîç Debug branch name
        run: |
          echo "Branch actual: ${{ github.ref_name }}"
        
      - name: üìù Set Salesforce Environment Variables
        id: set_sf_env
        run: |
          BASE_REF="${GITHUB_BASE_REF:-${GITHUB_REF_NAME}}"
          echo "üîé Branch destino: $BASE_REF"

          if [[ "$BASE_REF" == "INTEGRA" ]]; then
            echo "LOGIN_URL=https://test.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_INTEGRA }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_INTEGRA }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_INTEGRA }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          elif [[ "$BASE_REF" == "UAT" ]]; then
            echo "LOGIN_URL=https://test.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_UAT }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_UAT }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_UAT }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          elif [[ "$BASE_REF" == "MAIN" ]]; then
            echo "LOGIN_URL=https://login.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_PROD }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_PROD }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_PROD }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "‚ùå Branch not supported"
            exit 1
          fi

      - name: ‚úç Verificar existencia y tama√±o del archivo JWT
        run: |
          echo "${{ env.JWT_KEY }}" > server.key
          if [ -f server.key ]; then
            echo "‚úÖ Archivo 'server.key' creado correctamente."
            ls -lh server.key
          else
            echo "‚ùå No se encontr√≥ el archivo 'server.key'."
            exit 1
          fi   

      - name: üîß Instalar Salesforce CLI
        run: |
          npm install --global @salesforce/cli

      - name: üõÇ Autenticarse en Salesforce con JWT
        env:
          SFDX_CLIENT_ID: ${{ env.CLIENT_ID }}
          SFDX_JWT_KEY: ${{ vars.SFDX_JWT_KEY_UAT }}
          SFDX_USERNAME: ${{ env.USERNAME }}
          SFDX_URL: ${{ env.LOGIN_URL }}
        run: |
          echo "$SFDX_JWT_KEY" > server.key
          sf org login jwt \
            --client-id "$SFDX_CLIENT_ID" \
            --jwt-key-file server.key \
            --username "$SFDX_USERNAME" \
            --instance-url "$SFDX_URL" \
            --alias SF

      - name: ‚úç Verify Authentication
        run: |
          sfdx force:org:list

      - name: üõ†Ô∏è Instalar xmllint
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils

      - name: üßπ Vaciar directorio de clases temporales
        run: |
          echo "Vaciando el directorio ./pmd/classes..."
          rm -rf ./pmd/classes/{*,.*} || true

      - name: üßº Analizar package.xml para buscar ApexClass o ApexTrigger
        id: analyze_package
        run: |
          # Ruta al package.xml
          PACKAGE_XML="./manifest/package.xml"

          echo "üì¶ Analizando el archivo package.xml: $PACKAGE_XML"

          # Contar ApexClass
          CLASS_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexClass']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")
          CLASS_COUNT=$(echo "$CLASS_NAMES" | wc -w)
          echo "üìö N√∫mero de clases Apex en el package.xml: $CLASS_COUNT"

          # Contar ApexTrigger
          TRIGGER_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexTrigger']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")
          TRIGGER_COUNT=$(echo "$TRIGGER_NAMES" | wc -w)
          echo "üß© N√∫mero de triggers en el package.xml: $TRIGGER_COUNT"

          if [ "$CLASS_COUNT" -eq 0 ] && [ "$TRIGGER_COUNT" -eq 0 ]; then
            echo "generate_manifest_only=true" >> $GITHUB_OUTPUT
          else
            echo "generate_manifest_only=false" >> $GITHUB_OUTPUT
          fi


      - name: üóÇÔ∏è Copiar Apex Classes y Triggers listados en package.xml
        if: steps.analyze_package.outputs.generate_manifest_only == 'false'
        run: | 
          # Directorios de origen y destino
          PACKAGE_XML="./manifest/package.xml"
          DEST_DIR="./pmd/classes"
          SRC_CLASSES_DIR="./force-app/main/default/classes"
          SRC_TRIGGERS_DIR="./force-app/main/default/triggers"

          echo "üì¶ Analizando: $PACKAGE_XML"

          # Extraer ApexClass
          CLASS_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexClass']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")

          # Extraer ApexTrigger
          TRIGGER_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexTrigger']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")

          # Separar m√∫ltiples entradas si vienen en una sola l√≠nea
          CLASS_NAMES=$(echo "$CLASS_NAMES" | tr ' ' '\n')
          TRIGGER_NAMES=$(echo "$TRIGGER_NAMES" | tr ' ' '\n')

          echo "üìö Clases a copiar:"
          echo "$CLASS_NAMES"
          echo "üß© Triggers a copiar:"
          echo "$TRIGGER_NAMES"

          # Crear el directorio destino si no existe
          mkdir -p "$DEST_DIR"

          # Copiar clases
          for class in $CLASS_NAMES; do
            echo "‚û°Ô∏è Procesando clase: '$class'"
            if [[ -f "$SRC_CLASSES_DIR/${class}.cls" ]]; then
              cp "$SRC_CLASSES_DIR/${class}.cls" "$DEST_DIR/"
              cp "$SRC_CLASSES_DIR/${class}.cls-meta.xml" "$DEST_DIR/"
              echo "‚úÖ Clase copiada: $class"
            else
              echo "‚ö†Ô∏è Clase no encontrada: $class"
            fi
          done

          # Copiar triggers
          for trigger in $TRIGGER_NAMES; do
            echo "‚û°Ô∏è Procesando trigger: '$trigger'"
            if [[ -f "$SRC_TRIGGERS_DIR/${trigger}.trigger" ]]; then
              cp "$SRC_TRIGGERS_DIR/${trigger}.trigger" "$DEST_DIR/"
              cp "$SRC_TRIGGERS_DIR/${trigger}.trigger-meta.xml" "$DEST_DIR/"
              echo "‚úÖ Trigger copiado: $trigger"
            else
              echo "‚ö†Ô∏è Trigger no encontrado: $trigger"
            fi
          done

          # Verificar los archivos copiados en el directorio destino
          echo "üìÇ Archivos en el directorio $DEST_DIR despu√©s de la copia:"
          ls -l "$DEST_DIR"

          echo "‚úÖ Archivos movidos a $DEST_DIR"

      - name: ‚ûï A√±adir DummyClassTest si no hay tests
        if: steps.analyze_package.outputs.generate_manifest_only == 'true'
        run: |
          # A√±adir bloque <types> de ApexClass justo antes del </Package>
          sed -i '/<\/Package>/i\
          <types>\n\
            <members>DummyClassTest</members>\n\
            <name>ApexClass</name>\n\
          </types>' ./manifest/package.xml

          echo "üßê Verificar contenido actualizado del package.xml"
          cat ./manifest/package.xml

      - name: üìÑ Ver contenido de las reglas
        run: cat ./config/apex-ruleset.xml

      - name: üßµ Install PMD
        if: steps.analyze_package.outputs.generate_manifest_only == 'false' 
        run: |
          curl -L -o pmd.zip https://github.com/pmd/pmd/releases/download/pmd_releases%2F6.55.0/pmd-bin-6.55.0.zip
          mkdir -p ./pmd/zip
          unzip pmd.zip -d ./pmd/zip
          mv ./pmd/zip/pmd-bin-6.55.0 ./pmd
          find ./pmd -mindepth 1 -maxdepth 1 -type d
          chmod +x ./pmd/bin/pmd

      - name: ‚ûï Agregar PMD al PATH
        run: echo "$GITHUB_WORKSPACE/pmd/bin" >> $GITHUB_PATH

      - name: üì° Ejecutar PMD sobre ./pmd/classes
        if: ${{ hashFiles('pmd/classes/**/*.cls') != '' }}
        run: |
          echo "‚è≥ Ejecutando PMD sobre ./pmd/classes..."
          mkdir -p ./pmd/report
          ./pmd/bin/pmd \
            --dir ./pmd/classes \
            --rulesets ./config/apex-ruleset.xml \
            --format text \
            --report-file ./pmd/report/pmd-report.txt 

          echo "üîé PMD Report:"
          cat ./pmd/report/pmd-report.txt

          if grep -q "^\[.*\]" ./pmd/report/pmd-report.txt; then
            echo "‚ùå PMD violations found."
            exit 1
          else
            echo "‚úÖ No PMD violations found."
          fi

      - name: üß≠ Validar todo el package.xml (con o sin clases de test)
        run: |
          echo "‚è≥ Buscando clases de test..."
          TEST_CLASSES=$(find ./pmd/classes -type f -name "*Test.cls" -exec basename {} .cls \; | paste -sd' ' -)

          if [ -n "$TEST_CLASSES" ]; then
            echo "üß™ Clases de test encontradas: $TEST_CLASSES. Validando componentes y clases tests"
            sf deploy metadata validate \
              --manifest ./manifest/package.xml \
              --target-org SF \
              --test-level RunSpecifiedTests \
              --tests "$TEST_CLASSES" \
              --json > validation-result.json || exit 1
          else
            echo "üß± No se encontraron clases de test. Validando solo los componentes"
            sf deploy metadata validate \
              --manifest ./manifest/package.xml \
              --target-org SF \
              --test-level RunSpecifiedTests \
              --tests DummyClass \
              --json > validation-result.json || exit 1
          fi

          echo "üì¢ Resultado de la validaci√≥n:"
          cat validation-result.json | jq

          DEPLOY_ID=$(jq -r '.result.id' validation-result.json)
          if [ -n "$DEPLOY_ID" ]; then
            mkdir -p .gh-deploy-data
            echo "$DEPLOY_ID" > .gh-deploy-data/validated-deploy-id.txt
          fi

      - name: üì¨ Guardar commit SHA
        run: |
          mkdir -p .gh-deploy-data
          echo "${{ github.event.pull_request.head.sha }}" > .gh-deploy-data/commit.txt
          echo "${{ github.event.pull_request.merge_commit_sha || github.sha }}" > .gh-deploy-data/merge-sha.txt  

      - name: üì§ Upload validated deploy ID as artifact
        uses: actions/upload-artifact@v4
        with:
          name: validated-deploy-id-${{ github.event.pull_request.head.sha }}
          path: |
            .gh-deploy-data/validated-deploy-id.txt
            .gh-deploy-data/commit.txt
            .gh-deploy-data/merge-sha.txt
          retention-days: 15  # importante para evitar expiraciones prematuras
