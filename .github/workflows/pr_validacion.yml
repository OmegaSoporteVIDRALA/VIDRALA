name: Validate Salesforce PR

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
      - name: ⬇️ Checkout repository
        uses: actions/checkout@v3
        
      - name: ⬇️ Checkout code
        uses: actions/checkout@v4

     # - name: ✒️ Determine target branch
       # id: check_branch
       # run: |
       #   echo "TARGET_BRANCH=${{ github.event.workflow_run.pull_requests[0].base.ref }}" >> $GITHUB_ENV
        ##  BRANCH="${{ github.event.workflow_run.pull_requests[0].base.ref }}"
        #  echo "Target branch is $BRANCH"
       #   if [[ "$BRANCH" != "integra" && "$BRANCH" != "uat" && "$BRANCH" != "main" ]]; then
        #    echo "❌ Deployment only allowed to integra, uat or main branches."
       #     exit 1
       #   fi
        
      - name: 📝 Set Salesforce Environment Variables
        id: set_sf_env
        run: |
          BASE_REF="${GITHUB_BASE_REF:-${GITHUB_REF_NAME}}"
          echo "🔎 Branch destino: $BASE_REF"

          if [[ "$BASE_REF" == "INTEGRA" ]]; then
            echo "LOGIN_URL=https://test.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_INTEGRA }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_INTEGRA }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_INTEGRA }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          elif [[ "$BASE_REF" == "UAT" ]]; then
            echo "LOGIN_URL=https://test.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_UAT }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_UAT }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_UAT }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          elif [[ "$BASE_REF" == "MAIN" ]]; then
            echo "LOGIN_URL=https://login.salesforce.com" >> $GITHUB_ENV
            echo "CLIENT_ID=${{ secrets.SFDX_CLIENT_ID_PROD }}" >> $GITHUB_ENV
            echo "USERNAME=${{ secrets.SFDX_USERNAME_PROD }}" >> $GITHUB_ENV
            echo "JWT_KEY<<EOF" >> $GITHUB_ENV
            echo "JWT_KEY=${{ secrets.SFDX_JWT_KEY_PROD }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            echo "❌ Branch not supported"
            exit 1
          fi

      - name: ✍ Verificar existencia y tamaño del archivo JWT
        run: |
          echo "${{ env.JWT_KEY }}" > server.key
          if [ -f server.key ]; then
            echo "✅ Archivo 'server.key' creado correctamente."
            ls -lh server.key
          else
            echo "❌ No se encontró el archivo 'server.key'."
            exit 1
          fi   

      - name: 🔧 Instalar Salesforce CLI
        run: |
          npm install --global @salesforce/cli

      - name: 🔐 Autenticarse en Salesforce con JWT
        env:
          SFDX_CLIENT_ID: ${{ env.CLIENT_ID }}
          SFDX_JWT_KEY: ${{ vars.SFDX_JWT_KEY_UAT }}
          SFDX_USERNAME: ${{ env.USERNAME }}
          SFDX_URL: ${{ env.LOGIN_URL }}
        run: |
          echo "$SFDX_JWT_KEY" > server.key
          sf org login jwt \
            --client-id "$SFDX_CLIENT_ID" \
            --jwt-key-file server.key \
            --username "$SFDX_USERNAME" \
            --instance-url "$SFDX_URL" \
            --alias SF

      - name: ✍ Verify Authentication
        run: |
          sfdx force:org:list

      - name: 🛠️ Instalar xmllint
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils

      - name: 🧹 Vaciar directorio de clases temporales
        run: |
          echo "Vaciando el directorio ./pmd/classes..."
          rm -rf ./pmd/classes/{*,.*} || true

      - name: 🔍 Analizar package.xml para buscar ApexClass o ApexTrigger
        id: analyze_package
        run: |
          PACKAGE_XML="./manifest/package.xml"
          TEMP_XML=$(mktemp)
          sed 's/xmlns="[^"]*"//' "$PACKAGE_XML" > "$TEMP_XML"

          APEX_CLASS_COUNT=$(xmllint --xpath "count(//types[name='ApexClass'])" "$TEMP_XML")
          TRIGGER_COUNT=$(xmllint --xpath "count(//types[name='ApexTrigger'])" "$TEMP_XML")

          echo "Apex classes: $APEX_CLASS_COUNT"
          echo "Triggers: $TRIGGER_COUNT"

          if [ "$APEX_CLASS_COUNT" -eq 0 ] && [ "$TRIGGER_COUNT" -eq 0 ]; then
            echo "generate_manifest_only=true" >> $GITHUB_OUTPUT
          else
            echo "generate_manifest_only=false" >> $GITHUB_OUTPUT
          fi

      - name: 📦 Preparar manifest_only sin clases ni triggers
        if: steps.analyze_package.outputs.generate_manifest_only == 'true'
        run: |
          mkdir -p manifest_only
          SRC_BASE="force-app/main/default"
          DEST_BASE="manifest_only"

          # Eliminar namespace para facilitar XPath
          sed 's/xmlns="[^"]*"//' ./manifest/package.xml > clean-package.xml

          # Extraer todos los pares tipo/miembro del XML
          types=()
          while IFS= read -r type_block; do
            type=$(echo "$type_block" | xmllint --xpath 'string(//types/name)' - 2>/dev/null)
            echo "$type_block" | xmllint --xpath '//types/members/text()' - 2>/dev/null | tr ' ' '\n' | while read member; do
              if [ -n "$member" ]; then
                # Ruta de tipo: convierte ApexPage → pages, ApexClass → classes, etc.
                folder=$(echo "$type" | sed -e 's/\([A-Z]\)/ \1/g' | awk '{print tolower($0)}' | tr -d ' ' | sed 's/\b\(.\)/\u\1/g' | tr '[:upper:]' '[:lower:]')
                
                # Ruta especial si existen nombres estándar
                case "$type" in
                  ApexClass) folder="classes" ;;
                  ApexTrigger) folder="triggers" ;;
                  ApexPage) folder="pages" ;;
                  ApexComponent) folder="components" ;;
                  StaticResource) folder="staticresources" ;;
                  CustomObject) folder="objects" ;;
                esac

                src_dir="$SRC_BASE/$folder"
                dest_dir="$DEST_BASE/$folder"
                mkdir -p "$dest_dir"

                # Copiar archivos que coincidan con el nombre del miembro
                find "$src_dir" -maxdepth 1 -type f -name "$member*" -exec cp {} "$dest_dir/" \; 2>/dev/null || true
              fi
            done
          done < <(csplit -sz clean-package.xml '/<types>/+1' '{*}' | grep -v '^\s*$')

          echo "✅ Todos los componentes del package.xml copiados a manifest_only"
          find manifest_only -type f

      - name: 📂 Copiar Apex Classes y Triggers listados en package.xml
        if: steps.analyze_package.outputs.generate_manifest_only == 'false'
        run: |
          # Directorios de origen y destino
          PACKAGE_XML="./manifest/package.xml"
          DEST_DIR="./pmd/classes"
          SRC_CLASSES_DIR="./force-app/main/default/classes"
          SRC_TRIGGERS_DIR="./force-app/main/default/triggers"

          echo "📦 Package path: $PACKAGE_XML"

          echo "🔍 Analizando package.xml..."

          # Extraer ApexClass
          CLASS_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexClass']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")
          echo "📚 Resultado de APEX_CLASSES: '$CLASS_NAMES'"

          # Extraer ApexTrigger
          TRIGGER_NAMES=$(xmllint --xpath "//*[local-name()='types']/*[local-name()='name'][text()='ApexTrigger']/../*[local-name()='members']/text()" "$PACKAGE_XML" 2>/dev/null || echo "")
          echo "🧩 Resultado de APEX_TRIGGERS: '$TRIGGER_NAMES'"

          # Copiar clases
          IFS=$'\n'
          for class in $CLASS_NAMES; do
            echo "📦 Copiando clase: $class"
            cp "force-app/main/default/classes/${class}.cls" "$DEST_DIR/" 2>/dev/null
            cp "force-app/main/default/classes/${class}.cls-meta.xml" "$DEST_DIR/" 2>/dev/null
          done

          # Copiar triggers
          for trigger in $TRIGGER_NAMES; do
            echo "📦 Copiando trigger: $trigger"
            cp "force-app/main/default/triggers/${trigger}.trigger" "$DEST_DIR/" 2>/dev/null
            cp "force-app/main/default/triggers/${trigger}.trigger-meta.xml" "$DEST_DIR/" 2>/dev/null
          done

          echo "✅ Archivos movidos a $DEST_DIR"


      - name: 🔍 Check if there are Test classes
        id: check_tests
        run: |
          if find ./pmd/classes -name '*.cls' | grep -q .; then
            echo "testfound=true" >> $GITHUB_ENV
          else
            echo "testfound=false" >> $GITHUB_ENV
          fi

      - name: 📄 Ver contenido de las reglas
        run: cat ./config/apex-ruleset.xml

      - name: 🧰 Install PMD
        if: env.testfound == 'true' && github.base_ref  == 'UAT' 
        run: |
          curl -L -o pmd.zip https://github.com/pmd/pmd/releases/download/pmd_releases%2F6.55.0/pmd-bin-6.55.0.zip
          unzip pmd.zip -d pmd
          mv pmd/pmd-bin-6.55.0 pmd-bin
          chmod +x pmd-bin/bin/run.sh

      - name: 🤖 Run Apex tests if it was found 
        if: env.testfound == 'true'
        run: |
          TEST_CLASSES=$(find ./pmd/classes -name "*Test.cls" -exec basename {} .cls \; | paste -sd, -)
          echo "🧪 Validating components with specific tests: $TEST_CLASSES...."
          sf deploy metadata validate \
            --manifest ./manifest/package.xml \
            --target-org SF \
            --test-level RunSpecifiedTests \
            --tests "$TEST_CLASSES" || exit 1
            
      - name: ⏰ Validate Salesforce components if no Apex tests was found
        if: env.testfound == 'false'
        run: |
          echo "📭 No test classes found. Validating components without tests..."

          # Ejecutar validación sin incluir Apex clases si no hay tests
           sf deploy metadata validate \
              --metadata-dir ./manifest_only \
              --target-org SF \
              --test-level RunLocalTests || exit 1